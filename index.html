<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>Enums.delegates.cppcli by Diagonactic</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Enums.delegates.cppcli</h1>
        <h2>High performance enum library for C# written generically with System.Enum constraint (in C++/CLI since C# doesn&#39;t support that!)</h2>

        <section id="downloads">
          <a href="https://github.com/Diagonactic/Enums.Delegates.CppCLI/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/Diagonactic/Enums.Delegates.CppCLI/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/Diagonactic/Enums.Delegates.CppCLI" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1>
<a id="enums-and-delegates-in-ccli" class="anchor" href="#enums-and-delegates-in-ccli" aria-hidden="true"><span class="octicon octicon-link"></span></a>Enums and Delegates in C++/CLI</h1>

<p>This project provides a set of highly performant generic methods for interacting with Enums.</p>

<p>Enums and Delegates are a fundimental component of .Net, however, as of version 6.0 of the
C# language, there's no way to (directly) constrain a generic parameter to System.Enum or 
System.Delegate.  There's so many reasons to want to do so, not the least of which is the 
set of kludgy static methods on Enum and Delegate that would really benefit from generic
implementations.  This project does just that with a series of helpful static and extension
methods that can be consumed by any .Net Language.</p>

<p>Delegate support at this time should be considered "beta". Enum support is quite solid.</p>

<p>See "Methodology.md" for more information</p>

<h2>
<a id="installing" class="anchor" href="#installing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installing</h2>

<p>The easiest way to get the application is via NuGet.</p>

<pre><code>Install-Package DiagonacticEnumsExtensions
</code></pre>

<h2>
<a id="enum-methods" class="anchor" href="#enum-methods" aria-hidden="true"><span class="octicon octicon-link"></span></a>Enum Methods</h2>

<p>Convert an enum to a string (with caching; see Methodology.md). Performs anywhere from 1.5-10 
times faster than ToString() with greatest performance on single enum values (16 times faster 
in unrealistic unit tests provided):</p>

<div class="highlight highlight-source-cs"><pre>MyEnum.MyEnumValue.AsString();</pre></div>

<p>Parses a string value or comma-separated string values to the enum type provided:</p>

<div class="highlight highlight-source-cs"><pre>Enums.Parse&lt;MyEnum&gt;(<span class="pl-s"><span class="pl-pds">"</span>MyEnumValue<span class="pl-pds">"</span></span>);</pre></div>

<p>Flag manipulation:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> result = MyEnum.Val1.AddFlag(MyEnum.Val2);  <span class="pl-c">// MyEnum.Val1 | MyEnum.Val2</span>
result.AddFlags(MyEnum.Val3, MyEnum.Val4); <span class="pl-c">// MyEnum.Val1 | MyEnum.Val2 | MyEnum.Val3 | MyEnum.Val4</span>
result.RemoveFlag(MyEnum.Val3); <span class="pl-c">// MyEnum.Val1 | MyEnum.Val2 | MyEnum.Val4</span>
result.RemoveFlags(MyEnum.Val1, MyEnum.Val4); <span class="pl-c">// MyEnum.Val2</span>

<span class="pl-c">// AddFlagIf, RemoveFlagIf and ModifyFlag all have delegate and predicate overloads.</span>
result = MyEnum.Val1 | MyEnum.Val2
result.AddFlagIf(MyEnum.Val3, () =&gt; <span class="pl-c1">true</span>); <span class="pl-c">// MyEnum.Val1 | MyEnum.Val2 | MyEnum.Val3</span>
result.AddFlagIf(MyEnum.Val3, (s) =&gt; s.IsFlagSet(MyEnum.Val1)); <span class="pl-c">// Val3 already added, same as above</span>
result.AddFlagIf(MyEnum.Val4, <span class="pl-c1">true</span>); <span class="pl-c">// MyEnum.Val1 | MyEnum.Val2 | MyEnum.Val3 | MyEnum.Val4</span>

result = MyEnum.Val1 | MyEnum.Val2
result.RemoveFlagIf(MyEnum.Val1, <span class="pl-c1">false</span>); <span class="pl-c">// MyEnum.Val1 | MyEnum.Val2</span>
result.RemoveFlagIf(MyEnum.Val1, () =&gt; <span class="pl-c1">true</span>); <span class="pl-c">// MyEnum.Val2</span>

result = MyEnum.Val1
result.ModifyFlag(MyEnum.Val2, <span class="pl-c1">true</span>); <span class="pl-c">// MyEnum.Val1 | MyEnum.Val2 (sets if true)</span>
result.ModifyFlag(MyEnum.Val2, <span class="pl-c1">false</span>); <span class="pl-c">// MyEnum.Val1 (removes if false)</span>
</pre></div>

<p>Testing enum values (AreAny/AreAll)</p>

<div class="highlight highlight-source-cs"><pre>MyEnum.Val1.AreAnyFlagsSet(MyEnum.Val1, MyEnum.Val2, MyEnum.Val3); <span class="pl-c">// true</span>
MyEnum.Val1.EqualsAny(MyEnum.Val1, MyEnum.Val2, MyEnum.Val3); <span class="pl-c">// true - like the above but for non-flags enums</span>
MyEnum.Val1.AreAllFlagsSet(MyEnum.Val1, MyEnum.Val2, MyEnum.Val3); <span class="pl-c">// false</span>
MyEnum.Val1.IsFlagSet(MyEnum.Val1); <span class="pl-c">// true - performs better than HasFlag</span>
MyEnum.Val1.IsFlagSet(MyEnum.Val2); <span class="pl-c">// false</span></pre></div>

<p>Get the value of the DescriptionAttribute.Description or convert MyEnumValue to "My Enum Value"
if DescriptionAttribute is missing:</p>

<div class="highlight highlight-source-cs"><pre>MyEnum.MyEnumValue.GetDescription();</pre></div>

<p>Convert an underlying type (numeric) value to the enum type:</p>

<div class="highlight highlight-source-cs"><pre>Enums.ToEnum(<span class="pl-c1">1</span>); <span class="pl-c">// MyEnum.Val1</span>
Enums.ToEnum(<span class="pl-c1">3</span>); <span class="pl-c">// MyEnum.Val1 | mMynum.Val2</span></pre></div>

<h2>
<a id="enum-tools" class="anchor" href="#enum-tools" aria-hidden="true"><span class="octicon octicon-link"></span></a>Enum Tools</h2>

<p><em>Enum_Equality_Comparer</em> Unfortunately, when using an enum as a dictionary key or within a HashSet, lookups incur a boxing/unboxing penalty
due to System.Enum not implementing IEquatable.  This makes their use in a HashSet, where performance is often an
important factor, less than ideal.  Once again, the usual solution requires an enum generic constraint that isn't
available in C#.  The generic static method Enum.EqualityComparer() will return a suitable EqualityComparer for
any enum type.  Its implementation uses the underlying type for generating the HashCode.</p>

<div class="highlight highlight-source-cs"><pre>    <span class="pl-k">var</span> MyDictionary = <span class="pl-k">new</span> Dictionary&lt;MyEnum, SomeOtherType&gt;(Enums.EqualityComparer&lt;MyEnum&gt;());</pre></div>

<p><em>Flags_Enum_Definitions</em> There are many ways to define a flags enum ranging from the messy decimal based integer to somewhat more
readable hex and shift notations.  With "using static Enums.Flag;" added to your using statement, there's now a third way that's
more readable than any of those.  Each is defined as a constant value using a type that makes them compatible with most of the
allowed underlying enum types.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> static Enums.Flag

[Flags]
<span class="pl-k">enum</span> <span class="pl-en">FlagsEnum</span> : <span class="pl-k">byte</span>
{
    FirstFlag = F1,
    SecondFlag = F2,
    ThirdFlag = F3,
    <span class="pl-c">// ... types encoded from byte to Int64 for (near) universal usage ...</span>
}</pre></div>

<h2>
<a id="performance" class="anchor" href="#performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Performance</h2>

<p>Each of the conditional types (AddFlagIf/RemoveFlagIf/ModifyFlag) can be called with a boolean, a
function that returns a boolean or a Predicate delegate which will have its original value passed in
as the parameter.</p>

<p>The library is micro-optimized for execution speed. Where trade-offs between memory utilization
and performance existed, speed was preferred.  Enums are small and the memory used is "per enum type" 
not per instance.  In addition to using high-performing casts, an MSIL project is included which 
rewrites the generic methods that convert from numeric values back to the generic TEnum in a 
"blind cast" sort of manner.</p>

<p>Most of the static methods available in the System.Enum class were re-implemented and perform
significantly faster than the built-in implementations (orders of magnitude in some cases), especially
if a call is made to more than one of the methods in Diagonactic.Enums (there is a small initialization
penalty but it rarely results in the first call taking longer than any of the static calls on 
System.Enum).</p>

<p>The convenience methods, such as AddFlags, are very performant but will never be able to perform as
well (or even close to as well) as direct binary math due to call overhead.  If your code is extremely
sensitive to performance, using the binary math versions will be a better choice.</p>

<p>BenchmarkDotNet was used for performance profiling and the Console.Profile project includes the
tests used to assist in micro-optimization.</p>

<p>See "Performance.md" for the benchmark results and comparisons against identical calls using the static
method versions (where appropriate).</p>

<h2>
<a id="compiling" class="anchor" href="#compiling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compiling</h2>

<p>Simply grab the repo via git, open in Visual Studio 2015, and run Build.  Visual Studio will
build the C++ project last and execute the MSIL conversion after build.  If you wish to work
with the library without the MSIL conversion, either switch to the Debug build or 
remove the post-build command from the Release mode.</p>

<p>Note that the C++/CLI project claims to be in "x64" configuration.  It's not accurate; the
project compiles in "AnyCPU" mode with no 32-bit preference applied.  C++/CLI has no "AnyCPU"
built-in mode but with the right settings in the project, one can be created when the library
code can be fully represented in MSIL.  Yay! No Side-by-Side nonsense.</p>

<h2>
<a id="documentation" class="anchor" href="#documentation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Documentation</h2>

<p>It's well documented using XML docs and SandCastle (which produces a CHM, and web site).</p>
      </section>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-67310228-2");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
