{"name":"Enums.delegates.cppcli","tagline":"High performance enum library for C# written generically with System.Enum constraint (in C++/CLI since C# doesn't support that!)","body":"Enums and Delegates in C++/CLI\r\n==============================\r\n\r\nThis project provides a set of highly performant generic methods for interacting with Enums.\r\n\r\nEnums and Delegates are a fundimental component of .Net, however, as of version 6.0 of the\r\nC# language, there's no way to (directly) constrain a generic parameter to System.Enum or \r\nSystem.Delegate.  There's so many reasons to want to do so, not the least of which is the \r\nset of kludgy static methods on Enum and Delegate that would really benefit from generic\r\nimplementations.  This project does just that with a series of helpful static and extension\r\nmethods that can be consumed by any .Net Language.\r\n\r\nDelegate support at this time should be considered \"beta\". Enum support is quite solid.\r\n\r\nSee \"Methodology.md\" for more information\r\n\r\nInstalling\r\n----------\r\nThe easiest way to get the application is via NuGet.\r\n\r\n```\r\nInstall-Package DiagonacticEnumsExtensions\r\n```\r\n\r\nEnum Methods\r\n------------\r\nConvert an enum to a string (with caching; see Methodology.md). Performs anywhere from 1.5-10 \r\ntimes faster than ToString() with greatest performance on single enum values (16 times faster \r\nin unrealistic unit tests provided):\r\n```c#\r\nMyEnum.MyEnumValue.AsString();\r\n```\r\n\r\nParses a string value or comma-separated string values to the enum type provided:\r\n```c#\r\nEnums.Parse<MyEnum>(\"MyEnumValue\");\r\n```\r\n\r\nFlag manipulation:\r\n```c#\r\nvar result = MyEnum.Val1.AddFlag(MyEnum.Val2);  // MyEnum.Val1 | MyEnum.Val2\r\nresult.AddFlags(MyEnum.Val3, MyEnum.Val4); // MyEnum.Val1 | MyEnum.Val2 | MyEnum.Val3 | MyEnum.Val4\r\nresult.RemoveFlag(MyEnum.Val3); // MyEnum.Val1 | MyEnum.Val2 | MyEnum.Val4\r\nresult.RemoveFlags(MyEnum.Val1, MyEnum.Val4); // MyEnum.Val2\r\n\r\n// AddFlagIf, RemoveFlagIf and ModifyFlag all have delegate and predicate overloads.\r\nresult = MyEnum.Val1 | MyEnum.Val2\r\nresult.AddFlagIf(MyEnum.Val3, () => true); // MyEnum.Val1 | MyEnum.Val2 | MyEnum.Val3\r\nresult.AddFlagIf(MyEnum.Val3, (s) => s.IsFlagSet(MyEnum.Val1)); // Val3 already added, same as above\r\nresult.AddFlagIf(MyEnum.Val4, true); // MyEnum.Val1 | MyEnum.Val2 | MyEnum.Val3 | MyEnum.Val4\r\n\r\nresult = MyEnum.Val1 | MyEnum.Val2\r\nresult.RemoveFlagIf(MyEnum.Val1, false); // MyEnum.Val1 | MyEnum.Val2\r\nresult.RemoveFlagIf(MyEnum.Val1, () => true); // MyEnum.Val2\r\n\r\nresult = MyEnum.Val1\r\nresult.ModifyFlag(MyEnum.Val2, true); // MyEnum.Val1 | MyEnum.Val2 (sets if true)\r\nresult.ModifyFlag(MyEnum.Val2, false); // MyEnum.Val1 (removes if false)\r\n\r\n```\r\n\r\nTesting enum values (AreAny/AreAll)\r\n```c#\r\nMyEnum.Val1.AreAnyFlagsSet(MyEnum.Val1, MyEnum.Val2, MyEnum.Val3); // true\r\nMyEnum.Val1.EqualsAny(MyEnum.Val1, MyEnum.Val2, MyEnum.Val3); // true - like the above but for non-flags enums\r\nMyEnum.Val1.AreAllFlagsSet(MyEnum.Val1, MyEnum.Val2, MyEnum.Val3); // false\r\nMyEnum.Val1.IsFlagSet(MyEnum.Val1); // true - performs better than HasFlag\r\nMyEnum.Val1.IsFlagSet(MyEnum.Val2); // false\r\n```\r\n\r\nGet the value of the DescriptionAttribute.Description or convert MyEnumValue to \"My Enum Value\"\r\nif DescriptionAttribute is missing:\r\n```c#\r\nMyEnum.MyEnumValue.GetDescription();\r\n```\r\n\r\nConvert an underlying type (numeric) value to the enum type:\r\n```c#\r\nEnums.ToEnum(1); // MyEnum.Val1\r\nEnums.ToEnum(3); // MyEnum.Val1 | mMynum.Val2\r\n```\r\n\r\nEnum Tools\r\n----------\r\n_Enum_Equality_Comparer_ Unfortunately, when using an enum as a dictionary key or within a HashSet, lookups incur a boxing/unboxing penalty\r\ndue to System.Enum not implementing IEquatable.  This makes their use in a HashSet, where performance is often an\r\nimportant factor, less than ideal.  Once again, the usual solution requires an enum generic constraint that isn't\r\navailable in C#.  The generic static method Enum.EqualityComparer() will return a suitable EqualityComparer for\r\nany enum type.  Its implementation uses the underlying type for generating the HashCode.\r\n\r\n```c#\r\n\tvar MyDictionary = new Dictionary<MyEnum, SomeOtherType>(Enums.EqualityComparer<MyEnum>());\r\n```\r\n\r\n_Flags_Enum_Definitions_ There are many ways to define a flags enum ranging from the messy decimal based integer to somewhat more\r\nreadable hex and shift notations.  With \"using static Enums.Flag;\" added to your using statement, there's now a third way that's\r\nmore readable than any of those.  Each is defined as a constant value using a type that makes them compatible with most of the\r\nallowed underlying enum types.\r\n\r\n```c#\r\nusing static Enums.Flag\r\n\r\n[Flags]\r\nenum FlagsEnum : byte\r\n{\r\n\tFirstFlag = F1,\r\n\tSecondFlag = F2,\r\n\tThirdFlag = F3,\r\n\t// ... types encoded from byte to Int64 for (near) universal usage ...\r\n}\r\n```\r\n\r\n\r\nPerformance\r\n-----------\r\n\r\nEach of the conditional types (AddFlagIf/RemoveFlagIf/ModifyFlag) can be called with a boolean, a\r\nfunction that returns a boolean or a Predicate delegate which will have its original value passed in\r\nas the parameter.\r\n\r\nThe library is micro-optimized for execution speed. Where trade-offs between memory utilization\r\nand performance existed, speed was preferred.  Enums are small and the memory used is \"per enum type\" \r\nnot per instance.  In addition to using high-performing casts, an MSIL project is included which \r\nrewrites the generic methods that convert from numeric values back to the generic TEnum in a \r\n\"blind cast\" sort of manner.\r\n\r\nMost of the static methods available in the System.Enum class were re-implemented and perform\r\nsignificantly faster than the built-in implementations (orders of magnitude in some cases), especially\r\nif a call is made to more than one of the methods in Diagonactic.Enums (there is a small initialization\r\npenalty but it rarely results in the first call taking longer than any of the static calls on \r\nSystem.Enum).\r\n\r\nThe convenience methods, such as AddFlags, are very performant but will never be able to perform as\r\nwell (or even close to as well) as direct binary math due to call overhead.  If your code is extremely\r\nsensitive to performance, using the binary math versions will be a better choice.\r\n\r\nBenchmarkDotNet was used for performance profiling and the Console.Profile project includes the\r\ntests used to assist in micro-optimization.\r\n\r\nSee \"Performance.md\" for the benchmark results and comparisons against identical calls using the static\r\nmethod versions (where appropriate).\r\n\r\nCompiling\r\n---------\r\n\r\nSimply grab the repo via git, open in Visual Studio 2015, and run Build.  Visual Studio will\r\nbuild the C++ project last and execute the MSIL conversion after build.  If you wish to work\r\nwith the library without the MSIL conversion, either switch to the Debug build or \r\nremove the post-build command from the Release mode.\r\n\r\nNote that the C++/CLI project claims to be in \"x64\" configuration.  It's not accurate; the\r\nproject compiles in \"AnyCPU\" mode with no 32-bit preference applied.  C++/CLI has no \"AnyCPU\"\r\nbuilt-in mode but with the right settings in the project, one can be created when the library\r\ncode can be fully represented in MSIL.  Yay! No Side-by-Side nonsense.\r\n\r\nDocumentation\r\n-------------\r\nIt's well documented using XML docs and SandCastle (which produces a CHM, and web site).\r\n","google":"UA-67310228-2","note":"Don't delete this file! It's used internally to help with page regeneration."}