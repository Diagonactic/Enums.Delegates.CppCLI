{"name":"Enums.delegates.cppcli","tagline":"High performance enum library for C# written generically with System.Enum constraint (in C++/CLI since C# doesn't support that!)","body":"Enums and Delegates in C++/CLI\r\n==============================\r\n\r\nEnums and Delegates are a fundimental component of .Net, however, as of version 6.0 of the\r\nC# language, there's no way to (directly) constrain a generic parameter to System.Enum or \r\nSystem.Delegate.  There's so many reasons to want to do so, not the least of which is the \r\nset of kludgy static methods on Enum and Delegate that would really benefit from generic\r\nimplementations.  This project does just that with a series of helpful static and extension\r\nmethods that can be consumed by any .Net Language.\r\n\r\nDelegate support at this time should be considered \"beta\". Enum support is quite solid.\r\n\r\nA great deal of care was taken to ensure that this implementation is extremely fast.  Where\r\ntrade-offs between memory and speed were possible, speed was preferred. Enums are small and\r\nthe memory used is \"per type\" not per instance.  In addition to using high-performing casts,\r\nan MSIL project is included which rewrites the generic methods that convert from numeric\r\nvalues back to the generic TEnum in a \"blind cast\" sort of manner.\r\n\r\nSee \"Methodology.md\" for more information\r\n\r\nInstalling\r\n----------\r\nThe easiest way to get the application is via NuGet.\r\n\r\n```\r\nInstall-Package DiagonacticEnumsExtensions\r\n```\r\n\r\nEnum Methods\r\n------------\r\nConvert an enum to a string (with caching; see Methodology.md). Performs anywhere from 1.5-10 \r\ntimes faster than ToString() with greatest performance on single enum values (16 times faster \r\nin unrealistic unit tests provided):\r\n```c#\r\nMyEnum.MyEnumValue.AsString();\r\n```\r\n\r\nParses a string value or comma-separated string values to the enum type provided:\r\n```c#\r\nEnums.Parse<MyEnum>(\"MyEnumValue\");\r\n```\r\n\r\nFlag manipulation:\r\n```c#\r\nvar result = MyEnum.Val1.AddFlag(MyEnum.Val2);  // MyEnum.Val1 | MyEnum.Val2\r\nresult.AddFlags(MyEnum.Val3, MyEnum.Val4); // MyEnum.Val1 | MyEnum.Val2 | MyEnum.Val3 | MyEnum.Val4\r\nresult.RemoveFlag(MyEnum.Val3); // MyEnum.Val1 | MyEnum.Val2 | MyEnum.Val4\r\nresult.RemoveFlags(MyEnum.Val1, MyEnum.Val4); // MyEnum.Val2\r\n\r\n// AddFlagIf, RemoveFlagIf and ModifyFlag all have delegate and predicate overloads.\r\nresult = MyEnum.Val1 | MyEnum.Val2\r\nresult.AddFlagIf(MyEnum.Val3, () => true); // MyEnum.Val1 | MyEnum.Val2 | MyEnum.Val3\r\nresult.AddFlagIf(MyEnum.Val3, (s) => s.IsFlagSet(MyEnum.Val1)); // Val3 already added, same as above\r\nresult.AddFlagIf(MyEnum.Val4, true); // MyEnum.Val1 | MyEnum.Val2 | MyEnum.Val3 | MyEnum.Val4\r\n\r\nresult = MyEnum.Val1 | MyEnum.Val2\r\nresult.RemoveFlagIf(MyEnum.Val1, false); // MyEnum.Val1 | MyEnum.Val2\r\nresult.RemoveFlagIf(MyEnum.Val1, () => true); // MyEnum.Val2\r\n\r\nresult = MyEnum.Val1\r\nresult.ModifyFlag(MyEnum.Val2, true); // MyEnum.Val1 | MyEnum.Val2 (sets if true)\r\nresult.ModifyFlag(MyEnum.Val2, false); // MyEnum.Val1 (removes if false)\r\n\r\n```\r\n\r\nTesting enum values (AreAny/AreAll)\r\n```c#\r\nMyEnum.Val1.AreAnyFlagsSet(MyEnum.Val1, MyEnum.Val2, MyEnum.Val3); // true\r\nMyEnum.Val1.EqualsAny(MyEnum.Val1, MyEnum.Val2, MyEnum.Val3); // true - like the above but for non-flags enums\r\nMyEnum.Val1.AreAllFlagsSet(MyEnum.Val1, MyEnum.Val2, MyEnum.Val3); // false\r\nMyEnum.Val1.IsFlagSet(MyEnum.Val1); // true - performs better than HasFlag\r\nMyEnum.Val1.IsFlagSet(MyEnum.Val2); // false\r\n```\r\n\r\nGet the value of the DescriptionAttribute.Description or convert MyEnumValue to \"My Enum Value\"\r\nif DescriptionAttribute is missing:\r\n```c#\r\nMyEnum.MyEnumValue.GetDescription();\r\n```\r\n\r\nConvert an underlying type (numeric) value to the enum type:\r\n```c#\r\nEnums.ToEnum(1); // MyEnum.Val1\r\nEnums.ToEnum(3); // MyEnum.Val1 | mMynum.Val2\r\n```\r\n\r\nDefine a flags enum conveniently (C# 6.0):\r\n```c#\r\nusing static Enums.Flag\r\n\r\n[Flags]\r\nenum FlagsEnum : byte\r\n{\r\n\tFirstFlag = F1,\r\n\tSecondFlag = F2,\r\n\tThirdFlag = F3,\r\n\t// ... types encoded from byte to Int64 for (near) universal usage ...\r\n}\r\n```\r\n\r\nEach of the conditional types (AddFlagIf/RemoveFlagIf/ModifyFlag) can be called with a boolean, a\r\nfunction that returns a boolean or a Predicate delegate which will have its original value passed in\r\nas the parameter.\r\nCompiling\r\n---------\r\n\r\nSimply grab the repo via git, open in Visual Studio 2015, and run Build.  Visual Studio will\r\nbuild the C++ project last and execute the MSIL conversion after build.  If you wish to work\r\nwith the library without the MSIL conversion, either switch to the Debug build or \r\nremove the post-build command from the Release mode.\r\n\r\nNote that the C++/CLI project claims to be in \"x64\" configuration.  It's not accurate; the\r\nproject compiles in \"AnyCPU\" mode with no 32-bit preference applied.  C++/CLI has no \"AnyCPU\"\r\nbuilt-in mode but with the right settings in the project, one can be created when the library\r\ncode can be fully represented in MSIL.  Yay! No Side-by-Side nonsense.\r\n\r\nDocumentation\r\n-------------\r\nIt's well documented using XML docs and SandCastle (which produces a CHM, and web site).\r\n","google":"UA-67310228-2","note":"Don't delete this file! It's used internally to help with page regeneration."}